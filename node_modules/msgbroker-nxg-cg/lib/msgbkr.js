const {randomNum} = require('../helpers/randomNum');
const amqp = require('amqplib');
const {constants, helpers, log} = require('utils-nxg-cg');
const error_queue = 'error-queue';
const deadletter = 'deadletter';
const message_queue = 'message-queue';
const analitics = 'analitics';

/**
 * Method that creates a listener for a queue
 *
 */
const errorQueueListener = async () => {
    try{
        const random = randomNum();
        let exchangeDLX = error_queue;
        let queueDLX = `${error_queue}:${random}:${deadletter}`;
        let routingKey = `${error_queue}.${random}.${deadletter}`;
        if (constants.ELASTICIO_LISTEN_MESSAGES_ON) {
        	const componentProp = constants.ELASTICIO_LISTEN_MESSAGES_ON.split(":");
        	if (componentProp) {
		        exchangeDLX = componentProp[0];
		        queueDLX = `${componentProp[0]}:${componentProp[1]}:${deadletter}`;
		        routingKey = `${componentProp[0]}.${componentProp[1]}.${deadletter}`;
	        }
        }
        log.info(queueDLX);

        let connection = await amqp.connect(constants.URI_RABBITMQ);

        const ch = await connection.createChannel();

        await ch.assertExchange(exchangeDLX, 'topic', {durable: true});

        const queue = await ch.assertQueue(queueDLX, {
            exclusive: false
        });

        await ch.bindQueue(queue.queue, exchangeDLX, routingKey);

        await ch.close();
    }catch (e){
        log.error(`ERROR on message broker: ${e}`);
    }
};

/**
 * Method that produces messages to a specific queue
 *
 * @param message the message to be sent to a queue
 * @param queueName the name of the queue to send the message
 *
 */
const producerMessage = async (message, queueName) => {
    try{
        let exchangeDLX = message_queue;
        let queueDLX = `${message_queue}:${queueName}:${analitics}`;
        let routingKey = `${message_queue}.${queueName}.${analitics}`;
        if (constants.ELASTICIO_LISTEN_MESSAGES_ON) {
        	const componentProp = constants.ELASTICIO_LISTEN_MESSAGES_ON.split(":");
        	if (componentProp) {
		        exchangeDLX = componentProp[0];
		        queueDLX = `${componentProp[0]}:${queueName}:${analitics}`;
		        routingKey = `${componentProp[0]}.${queueName}.${analitics}`;
	        }
        }
        log.info(queueDLX);

        let connection = await amqp.connect(constants.URI_RABBITMQ);

        const ch = await connection.createChannel();

        await ch.assertExchange(exchangeDLX, 'topic', {durable: true});

        const queue = await ch.assertQueue(queueDLX, {
            exclusive: false
        });

        await ch.bindQueue(queue.queue, exchangeDLX, routingKey);

        //ch.sendToQueue(queue.queue, new Buffer.from(message.toString()),{persistent: true});
        const trace = {"message": JSON.stringify(message)};
        ch.publish(exchangeDLX, routingKey, new Buffer.from(JSON.stringify(trace)),{persistent: true});

        await ch.close();
    }catch (e){
        log.error(`ERROR on message broker: ${e}`);
    }
};


/**
 * Method that send a message for errors to a specific queue
 *
 * @param payload the content of the request
 * @param error the error received 
 *
 */
const producerErrorMessage = async (payload, error) => {
    try{
        const random = randomNum();
        let exchangeDLX = error_queue;
        let queueDLX = `${error_queue}:${random}:${deadletter}`;
        let routingKey = `${error_queue}.${random}.${deadletter}`;
        if (constants.ELASTICIO_LISTEN_MESSAGES_ON) {
        	const componentProp = constants.ELASTICIO_LISTEN_MESSAGES_ON.split(":");
        	if (componentProp) {
		        exchangeDLX = componentProp[0];
		        queueDLX = `${componentProp[0]}:${componentProp[1]}:${deadletter}`;
		        routingKey = `${componentProp[0]}.${componentProp[1]}.${deadletter}`;
	        }
        }
        log.info(queueDLX);

        let connection = await amqp.connect(constants.URI_RABBITMQ);

        const ch = await connection.createChannel();

        await ch.assertExchange(exchangeDLX, 'topic', {durable: true});

        const queue = await ch.assertQueue(queueDLX, {
            exclusive: false
        });

        await ch.bindQueue(queue.queue, exchangeDLX, routingKey);

        //ch.sendToQueue(queue.queue, new Buffer.from(message.toString()),{persistent: true});
        let emsg;
        if (helpers.isObjectValid(error)) {
			emsg = JSON.stringify(error);
		} else {
			emsg = error.toString();
		}
        
        const trace = {"error-message": emsg, "payload": JSON.stringify(payload)};
        ch.publish(exchangeDLX, routingKey, new Buffer.from(JSON.stringify(trace)), {persistent: true});

        await ch.close();
    }catch (e){
        log.error(`ERROR on message broker: ${e}`);
    }
};

module.exports = {
	errorQueueListener,
	producerMessage,
	producerErrorMessage
}
