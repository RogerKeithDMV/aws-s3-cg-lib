const path = require('path');
const {dirname} = require('path');
const fs = require('fs');
const Joi = require('joi');
const {XMLValidator} = require('fast-xml-parser');
const Encoding = require('encoding-japanese');
const {ERROR_PROPERTY, ERROR_CONVERT_ENCODING} = require('./constants');

/**
 * object that contains to allow encodings
 * @type {{ASCII: string}}
 */
const validEncodings = {
    ASCII: 'ASCII',
    UTF8: 'UTF8',
    SJIS: 'SJIS'
};

/**
 * Method for convert the following encodings to utf8 without validations
 * ascii
 * binary
 * latin1
 * utf8
 * utf-8
 * @param text
 * @returns {string}
 */
const _convertToUtf8 = (text) => Buffer.from(text, 'utf8').toString();

/**
 * Method for convert the base4 encoding to utf8
 * @param text
 * @returns {string}
 */
const convertBase64ToUtf8 = (text) => Buffer.from(text, 'base64').toString();

/**
 * Method for convert the base46url encoding to utf8
 * @param text
 * @returns {string}
 */
const convertBase64UrlToUtf8 = (text) => Buffer.from(text, 'base64url').toString();

/**
 * Method to convert any parameter as object or array
 * @param param
 * @returns {{}|any}
 */
function convertToObject(param) {
    let result = param;
    if (!param) return {};
    if (!validEncodings[Encoding.detect(param)]) throw Error(ERROR_CONVERT_ENCODING);
    if (validateHex(param)) throw Error(ERROR_CONVERT_ENCODING);
    if (_isObjectValid(param)) return param;
    if (_isObject(param)) return param;
    if (Array.isArray(param)) return param;
    if (validateBase64(param)) {
        result = convertBase64ToUtf8(param);
        if (!result) {
            result = convertBase64UrlToUtf8(param);
        }
    } else if (Buffer.isBuffer(param)) {
        result = _convertToUtf8(param);
    }
    try {
        result = _convertToUtf8(result);
        return JSON.parse(result);
    } catch (e) {
        try {
            result = _convertToUtf8(result);
            return JSON.parse(JSON.stringify(result));
        } catch (e) {
            throw Error(ERROR_CONVERT_ENCODING)
        }
    }
}

/**
 * Method for convert the following encodings to utf8
 * ascii
 * binary
 * latin1
 * utf8
 * utf-8
 * @param text
 * @returns {string}
 */
const convertToUtf8 = (text) => {
    if (!text) throw Error(ERROR_CONVERT_ENCODING);
    if (!validEncodings[Encoding.detect(text)]) throw Error(ERROR_CONVERT_ENCODING);
    if (validateHex(text)) throw Error(ERROR_CONVERT_ENCODING);
    if (typeof text === 'string') {
        if (validateBase64(text)) {
            let result = convertBase64ToUtf8(text);
            if (result) {
                return result;
            }
            return convertBase64UrlToUtf8(text);
        } else if (_isObjectValid(text)) {
            return text;
        } else {
            return _convertToUtf8(text);
        }
    } else if (_isObjectValid(text)) {
        return text;
    } else {
        return _convertToUtf8(text);
    }
};

/**
 * Remove File
 * @param uploadPath
 * @returns {boolean}
 */
const deleteFile = async (uploadPath) => {
    if (fs.existsSync(uploadPath)) {
        try {
            fs.rmSync(uploadPath);
            return true;
        } catch (e) {
            throw Error(e);
        }
    }
};

/**
 * Method for create a directory
 * @param directory
 * @param rootPath
 * @returns {string|boolean}
 */
const helperDirectory = (directory = '', rootPath = false) => {
    if (!directory)
        return false;
    let _rootPath = rootPath ? path.join(dirname(require.main.filename), directory)
        : path.join(__dirname, directory);
    if (!fs.existsSync(_rootPath))
        fs.mkdirSync(_rootPath, {recursive: true});
    return _rootPath;
};

/**
 * Method for validate if any parameter is an object
 * @param param
 * @returns {boolean}
 * @private
 */
const _isObject = (param) => {
    if (Array.isArray(param))
        return true
    return Object.getPrototypeOf(param) === Object.prototype;
}

/**
 * Method for validate if any parameter is an object
 * @param param
 * @returns {boolean}
 */
const isObject = (param) => {
    if (!param) return false;
    if (!validEncodings[Encoding.detect(param)]) return false;
    if (validateHex(param)) return false;
    if (Array.isArray(param) /*&& param.length > 0*/) return true;
    if (typeof param === 'string') {
        if (validateBase64(param)) {
            if (_isObject(JSON.parse(convertBase64ToUtf8(param)))) {
                return true;
            }
            return _isObject(JSON.parse(convertBase64UrlToUtf8(param)));
        } else {
            let obj = JSON.parse((_convertToUtf8(param)));
            return obj === Object(obj);
            //return obj === Object(obj) && Object.prototype.toString.call(obj) !== '[object Array]';
            //return (typeof Object(JSON.parse(JSON.stringify(convertToUtf8(param)))) === "object");
        }
    } else if (Buffer.isBuffer(param)) {
        return _isObject(JSON.parse(_convertToUtf8(param)));
    } else {
        return _isObject(param);
    }
};

/**
 * Method for validate if any parameter is an object, and it's not empty
 * @param param
 * @returns {boolean}
 * @private
 */
const _isObjectValid = (param) => {
    if (Array.isArray(param))
        return true;
    return Object.getPrototypeOf(param) === Object.prototype && Object.keys(param).length > 0;
};

/**
 * Method for validate if any parameter is an object, and it's not empty
 * @param param
 * @returns {boolean}
 */
const isObjectValid = (param) => {
    if (!param) return false;
    if (!validEncodings[Encoding.detect(param)]) return false;
    if (validateHex(param)) return false;
    if (Array.isArray(param) /*&& param.length > 0*/) return true;
    if (typeof param === 'string') {
        if (validateBase64(param)) {
            if (_isObjectValid(convertBase64ToUtf8(param))) {
                return true;
            }
            return _isObjectValid(JSON.parse(convertBase64UrlToUtf8(param)));
        } else {
            let obj = JSON.parse((_convertToUtf8(param)));
            return obj === Object(obj) && Object.keys(obj).length > 0;
        }
    } else if (Buffer.isBuffer(param)) {
        return _isObjectValid(JSON.parse(_convertToUtf8(param)));
    } else {
        return _isObjectValid(param);
    }
};

/**
 * This function creates a random number used when a queue can't be defined
 * @returns {string}
 */
function randomNum() {
    return Math.random().toString().split(".")[1].substring(0, 8);
}

/**
 * Method for remove customTimeZone, thi remove is only on memory
 */
const removeCustomTimeZone = () => {
    delete process.env['TZ'];
};

/**
 * Save File
 * @param properties
 * @param base64
 * @returns {String}
 */
const saveFile = (properties, base64 = true) => {
    const {file, content} = properties;
    const rootPath = helperDirectory('uploads');
    const uploadPath = path.join(rootPath, file);
    try {
        const encoding = base64 ? 'base64' : 'utf8';
        fs.writeFileSync(uploadPath, content, {encoding});
        return uploadPath;
    } catch (e) {
        throw Error(e);
    }
};

/**
 * Method for set TimeZone in env system, this env system only create on memory
 * @param text
 */
const setTimeZone = (text) => {
    process.env['TZ'] = text;
};

/**
 * Method for valid properties
 * @param properties
 * @param data
 * @param cfg
 * @param optional
 * @returns {boolean}
 */
const validProperties = (properties = {}, data = {}, cfg = {}, optional = false) => {
    Object.keys(properties).forEach((value) => {
        if (data.hasOwnProperty(value) && data[value]) {
            properties[value] = data[value];
        } else if (cfg.hasOwnProperty(value) && cfg[value]) {
            properties[value] = cfg[value];
        } else {
            if (optional)
                properties[value] = properties[value];
            else
                throw Error(`${ERROR_PROPERTY} ${value}`);
        }
    });
    return true;
};

/**
 * Method to validate is parameter is base64 format or base64url format
 * @param value
 * @returns {boolean}
 */
function validateBase64(value) {
    if (!value) return false;
    if (validateHex(value)) throw Error(ERROR_CONVERT_ENCODING);
    const Base64 = Joi.string().base64({paddingRequired: false, urlSafe: true});
    const Base64u = Joi.string().base64({paddingRequired: true, urlSafe: false});
    const {error: e} = Base64.validate(value);
    if (!e) return true;
    const {error} = Base64u.validate(value);
    return !error;
}

/**
 * validate if value is hexadecimal encoding
 * @param value
 * @returns {boolean}
 */
function validateHex(value) {
    if (!value) return false;
    let hex = Joi.string().hex({byteAligned: true});
    let hex2 = Joi.string().hex({byteAligned: false});
    const {error: e} = hex.validate(value);
    if (!e) return true;
    const {error} = hex2.validate(value);
    return !error;
}

/**
 * Method to validate XML structure
 * @param text
 * @returns {boolean|boolean|{err: {code: string, msg: string, line: number, col: number}}}
 */
const validateXMLStructure = (text) => {
    if (!text) return false;
    let result;
    if (validateBase64(text)) {
        result = XMLValidator.validate(convertBase64ToUtf8(text), {allowBooleanAttributes: true});
        if (_isObjectValid(result))
            return false;
        result = XMLValidator.validate(convertBase64UrlToUtf8(text), {allowBooleanAttributes: true});
    } else
        result = XMLValidator.validate(_convertToUtf8(text), {allowBooleanAttributes: true});
    if (_isObjectValid(result))
        return false;
    return result;
};

module.exports = {
    convertBase64ToUtf8,
    convertToObject,
    convertToUtf8,
    deleteFile,
    helperDirectory,
    isObject,
    isObjectValid,
    randomNum,
    removeCustomTimeZone,
    saveFile,
    setTimeZone,
    validProperties,
    validateBase64,
    validateHex,
    validateXMLStructure
};
